---
title: 'Collaborative Editing'
description: 'Collaborative editing in Gumnut'
icon: 'users'
---

This guide covers how to implement collaborative editing features in your application using Gumnut, with practical examples and best practices.

## Basic Collaborative Editing Setup

### Step 1: Set up the Document Structure

First, determine the structure of your collaborative document. In Gumnut, documents are made up of nodes, which can represent different parts of your content:

```javascript
// Example structure for a simple text document
const doc = gumnut.join(signal, 'document-id');

const titleNode = doc.forNode('title');
const contentNode = doc.forNode('content');
const metadataNode = doc.forNode('metadata');
```

### Step 2: Connect UI Components

Connect Gumnut nodes to UI components to enable editing:

```html
<!-- HTML Structure -->
<div class="document">
  <gumnut-input id="title-input" placeholder="Document Title"></gumnut-input>
  <gumnut-textarea id="content-editor"></gumnut-textarea>
</div>
```

```javascript
// Connect components to nodes
document.getElementById('title-input').node = titleNode;
document.getElementById('content-editor').node = contentNode;
```

### Step 3: Implement User Authentication

For identifying users in the collaborative session:

```javascript
// In development
const token = buildTestToken('user-123', {
  name: 'Alice Smith',
  email: 'alice@example.com'
});

// In production
const token = await fetchAuthTokenFromServer();

// Provide token to Gumnut
gumnut.provideToken(token);
```

### Step 4: Handle Document Lifecycle

Properly manage the document lifecycle to ensure changes are saved:

```javascript
// Create controllers for connection management
const connectionController = new AbortController();
const documentController = new AbortController();

// Set up the connection
const gumnut = connectToGumnut(connectionController.signal, {
  projectId: 'your-project-id'
});

// Join a document
const doc = gumnut.join(documentController.signal, 'document-id');

// Create snapshots when appropriate
function saveDocument() {
  doc.snapshot();
  console.log('Document snapshot created');
}

// Save periodically
const snapshotInterval = setInterval(saveDocument, 5 * 60 * 1000); // Every 5 minutes

// Clean up on page unload
window.addEventListener('beforeunload', () => {
  saveDocument();
  clearInterval(snapshotInterval);
  documentController.abort();
  connectionController.abort();
});
```

## Advanced Collaborative Features

### Multi-Section Documents

For more complex documents with multiple sections:

```html
<div class="document-sections">
  <div class="section">
    <h2>Introduction</h2>
    <gumnut-textarea id="section-intro"></gumnut-textarea>
  </div>
  <div class="section">
    <h2>Methodology</h2>
    <gumnut-textarea id="section-method"></gumnut-textarea>
  </div>
  <div class="section">
    <h2>Results</h2>
    <gumnut-textarea id="section-results"></gumnut-textarea>
  </div>
  <div class="section">
    <h2>Conclusion</h2>
    <gumnut-textarea id="section-conclusion"></gumnut-textarea>
  </div>
</div>
```

```javascript
// Connect each section to its own node
const sections = [
  { id: 'section-intro', node: 'introduction' },
  { id: 'section-method', node: 'methodology' },
  { id: 'section-results', node: 'results' },
  { id: 'section-conclusion', node: 'conclusion' }
];

sections.forEach(section => {
  document.getElementById(section.id).node = doc.forNode(section.node);
});
```

### Dynamic Section Management

Allow users to add, remove, or reorder sections:

```javascript
function addNewSection() {
  const sectionId = `section-${Date.now()}`;
  const nodeId = `content-${sectionId}`;
  
  // Create the UI
  const sectionDiv = document.createElement('div');
  sectionDiv.className = 'section';
  sectionDiv.dataset.id = sectionId;
  
  const heading = document.createElement('h2');
  heading.contentEditable = true;
  heading.textContent = 'New Section';
  
  const textarea = document.createElement('gumnut-textarea');
  textarea.id = sectionId;
  
  sectionDiv.appendChild(heading);
  sectionDiv.appendChild(textarea);
  document.querySelector('.document-sections').appendChild(sectionDiv);
  
  // Connect to a Gumnut node
  textarea.node = doc.forNode(nodeId);
  
  // Keep track of the section order in a metadata node
  updateSectionOrder();
}

function updateSectionOrder() {
  const sectionElements = document.querySelectorAll('.section');
  const sectionOrder = Array.from(sectionElements).map(el => el.dataset.id);
  
  // Store the section order in a metadata node
  const metadataNode = doc.forNode('section-order');
  metadataNode.perform({
    t: {
      at: 0,
      delete: -1,
      insert: JSON.stringify(sectionOrder)
    }
  });
}
```

### User Presence Indicators

Display which users are viewing/editing different sections:

```javascript
// Create a custom element to show user presence
class SectionPresence extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
    this.shadowRoot.innerHTML = `
      <style>
        :host {
          display: flex;
          gap: 6px;
          margin-bottom: 10px;
        }
        .user {
          display: inline-block;
          width: 28px;
          height: 28px;
          border-radius: 50%;
          background-color: var(--color, #ccc);
          font-size: 12px;
          line-height: 28px;
          text-align: center;
          color: white;
          font-weight: bold;
          cursor: pointer;
          position: relative;
        }
        .tooltip {
          position: absolute;
          bottom: 100%;
          left: 50%;
          transform: translateX(-50%);
          background: #333;
          color: white;
          padding: 4px 8px;
          border-radius: 4px;
          font-size: 12px;
          white-space: nowrap;
          visibility: hidden;
          opacity: 0;
          transition: opacity 0.2s;
        }
        .user:hover .tooltip {
          visibility: visible;
          opacity: 1;
        }
      </style>
      <div class="users"></div>
    `;
  }
  
  addUser(id, name, color) {
    const usersContainer = this.shadowRoot.querySelector('.users');
    
    // Check if user already exists
    if (this.shadowRoot.querySelector(`[data-id="${id}"]`)) {
      return;
    }
    
    const userElement = document.createElement('div');
    userElement.className = 'user';
    userElement.dataset.id = id;
    userElement.style.setProperty('--color', color);
    userElement.textContent = name.substring(0, 2).toUpperCase();
    
    const tooltip = document.createElement('div');
    tooltip.className = 'tooltip';
    tooltip.textContent = name;
    
    userElement.appendChild(tooltip);
    usersContainer.appendChild(userElement);
  }
  
  removeUser(id) {
    const user = this.shadowRoot.querySelector(`[data-id="${id}"]`);
    if (user) {
      user.remove();
    }
  }
}

// Register the custom element
customElements.define('section-presence', SectionPresence);

// Add presence indicators to sections
document.querySelectorAll('.section').forEach(section => {
  const presence = document.createElement('section-presence');
  section.insertBefore(presence, section.firstChild);
  
  // Get the corresponding textarea
  const textarea = section.querySelector('gumnut-textarea');
  if (!textarea || !textarea.node) return;
  
  // Monitor user presence on this node
  const nodeSignal = new AbortController();
  const internalNode = internalForNode(nodeSignal.signal, textarea.node);
  
  internalNode.addListener(() => {
    const users = new Map();
    
    // Get cursors from node
    const cursors = internalNode.cursors.read();
    
    for (const [clientId, sel] of cursors.entries()) {
      if (!clientId) continue;
      
      // Get user info
      const userId = internalNode.doc.userIdForClientId(clientId);
      if (!userId) continue;
      
      const userInfo = internalNode.gumnut.userInfo(userId);
      const name = userInfo?.name || userId;
      const color = colorForPeerHue(userId, null);
      
      users.set(userId, { name, color });
    }
    
    // Update presence display
    for (const [userId, { name, color }] of users.entries()) {
      presence.addUser(userId, name, color);
    }
  }, nodeSignal.signal);
});
```

### Commenting System

Implement a collaborative commenting system:

```javascript
// Comment data structure (in a separate node)
// {
//   id: "comment-123",
//   user: "user-456",
//   text: "This needs more explanation",
//   timestamp: 1647823456789,
//   position: { node: "content", offset: 120 }
// }

function addComment(text, position) {
  const commentsNode = doc.forNode('comments');
  
  // Get existing comments
  let comments = [];
  try {
    comments = JSON.parse(commentsNode.document().contents || '[]');
  } catch (e) {
    console.error('Failed to parse comments:', e);
  }
  
  // Add new comment
  const newComment = {
    id: `comment-${Date.now()}`,
    user: currentUserId,
    text: text,
    timestamp: Date.now(),
    position: position
  };
  
  comments.push(newComment);
  
  // Update comments node
  commentsNode.perform({
    t: {
      at: 0,
      delete: -1,
      insert: JSON.stringify(comments)
    }
  });
  
  // Display the comment in UI
  renderComment(newComment);
}

function renderComments() {
  const commentsNode = doc.forNode('comments');
  commentsNode.addListener(() => {
    let comments = [];
    try {
      comments = JSON.parse(commentsNode.document().contents || '[]');
    } catch (e) {
      return;
    }
    
    // Clear existing comment UI
    document.getElementById('comments-container').innerHTML = '';
    
    // Render each comment
    comments.forEach(renderComment);
  }, new AbortController().signal);
}

function renderComment(comment) {
  const commentElement = document.createElement('div');
  commentElement.className = 'comment';
  commentElement.dataset.id = comment.id;
  
  // Create comment content
  commentElement.innerHTML = `
    <div class="comment-header">
      <span class="user">${comment.user}</span>
      <span class="timestamp">${new Date(comment.timestamp).toLocaleString()}</span>
    </div>
    <div class="comment-text">${comment.text}</div>
    <div class="comment-actions">
      <button class="reply-btn">Reply</button>
      <button class="resolve-btn">Resolve</button>
    </div>
  `;
  
  // Position the comment relative to its target text
  positionCommentMarker(comment, commentElement);
  
  // Add to comments container
  document.getElementById('comments-container').appendChild(commentElement);
}

function positionCommentMarker(comment, element) {
  // Implementation depends on your UI layout
  // This is a simplified example
  if (!comment.position) return;
  
  // Find the target node
  const targetTextarea = document.querySelector(`gumnut-textarea[data-node="${comment.position.node}"]`);
  if (!targetTextarea) return;
  
  // Create a marker
  const marker = document.createElement('div');
  marker.className = 'comment-marker';
  marker.dataset.commentId = comment.id;
  
  // Position marker near the text
  // ...
  
  // Add marker to the document
  targetTextarea.parentNode.appendChild(marker);
  
  // Link marker and comment
  marker.addEventListener('click', () => {
    element.scrollIntoView({ behavior: 'smooth' });
    element.classList.add('highlight');
    setTimeout(() => element.classList.remove('highlight'), 2000);
  });
}
```

## Best Practices for Collaborative Editing

### Document Partitioning

For large documents, split content into logical nodes:

```javascript
// Instead of a single 'content' node for a large document
const introNode = doc.forNode('introduction');
const chaptersNode = doc.forNode('chapters');
const conclusionNode = doc.forNode('conclusion');

// For very large documents, further subdivide
for (let i = 1; i <= 10; i++) {
  const chapterNode = doc.forNode(`chapter-${i}`);
  // ...
}
```

### Handling Rich Text Content

For rich text editing, store formatted content as HTML or Markdown:

```javascript
// Using a rich text editor with Gumnut
const editor = new RichTextEditor('#editor');

// Connect to Gumnut
const contentNode = doc.forNode('rich-content');

// Initial content
editor.setContent(contentNode.document().contents || '');

// Send changes to Gumnut
editor.on('change', (newContent) => {
  contentNode.perform({
    t: {
      at: 0,
      delete: -1,
      insert: newContent
    }
  });
});

// Receive changes from Gumnut
contentNode.addListener(() => {
  const content = contentNode.document().contents;
  if (content !== editor.getContent()) {
    editor.setContent(content);
  }
}, new AbortController().signal);
```

### Optimizing for Performance

For better performance in collaborative editing:

1. **Throttle Updates**: For rapid-fire events like continuous typing

```javascript
function createThrottledPerform(node, delay = 50) {
  let pendingText = null;
  let timeout = null;
  
  return (text) => {
    pendingText = text;
    
    if (!timeout) {
      timeout = setTimeout(() => {
        node.perform({
          t: {
            at: 0,
            delete: -1,
            insert: pendingText
          }
        });
        pendingText = null;
        timeout = null;
      }, delay);
    }
  };
}

// Usage
const throttledUpdate = createThrottledPerform(someNode);
inputElement.addEventListener('input', (e) => {
  throttledUpdate(e.target.value);
});
```

2. **Debounce Snapshots**: Don't create snapshots too frequently

```javascript
function debounce(func, wait) {
  let timeout;
  return function(...args) {
    clearTimeout(timeout);
    timeout = setTimeout(() => func.apply(this, args), wait);
  };
}

const debouncedSnapshot = debounce(() => doc.snapshot(), 5000);

// Call after significant changes
saveButton.addEventListener('click', debouncedSnapshot);
```

3. **Use Node Structure Wisely**: Don't create too many tiny nodes or too few massive ones

### Managing User Notifications

Keep users informed about collaborative activities:

```javascript
// Create a notification system
class CollaborationNotifier {
  constructor(container) {
    this.container = container;
    this.notifications = [];
  }
  
  notify(message, type = 'info', duration = 5000) {
    const notification = document.createElement('div');
    notification.className = `notification ${type}`;
    notification.textContent = message;
    
    this.container.appendChild(notification);
    
    // Animate in
    requestAnimationFrame(() => {
      notification.style.transform = 'translateX(0)';
      notification.style.opacity = '1';
    });
    
    // Remove after duration
    const timeoutId = setTimeout(() => {
      this.removeNotification(notification);
    }, duration);
    
    this.notifications.push({ element: notification, timeoutId });
    
    return notification;
  }
  
  removeNotification(notification) {
    const index = this.notifications.findIndex(n => n.element === notification);
    if (index !== -1) {
      const { element, timeoutId } = this.notifications[index];
      clearTimeout(timeoutId);
      
      // Animate out
      element.style.opacity = '0';
      element.style.transform = 'translateX(100%)';
      
      // Remove from DOM after animation
      setTimeout(() => {
        this.container.removeChild(element);
      }, 300);
      
      this.notifications.splice(index, 1);
    }
  }
  
  clear() {
    this.notifications.forEach(({ element, timeoutId }) => {
      clearTimeout(timeoutId);
      this.container.removeChild(element);
    });
    this.notifications = [];
  }
}

// Create notification container
const notificationContainer = document.createElement('div');
notificationContainer.className = 'notification-container';
document.body.appendChild(notificationContainer);

const notifier = new CollaborationNotifier(notificationContainer);

// Listen for user join/leave events
gumnut.addUserListener((update) => {
  if (update.userId) {
    notifier.notify(`${update.name || update.userId} joined the document`, 'info');
  } else {
    notifier.notify(`A user left the document`, 'info');
  }
}, new AbortController().signal);
```

## Security Considerations

When implementing collaborative editing, keep these security aspects in mind:

1. **Authentication**: Ensure proper user authentication before granting access
2. **Document Access Control**: Implement server-side access controls for documents
3. **Input Validation**: Validate user input to prevent injection attacks
4. **Content Sanitization**: Sanitize HTML content if storing rich text
5. **Rate Limiting**: Prevent abuse by limiting operation frequency

## Conclusion

Collaborative editing with Gumnut enables powerful real-time interactions in your applications. By following the patterns and practices in this guide, you can create robust, performant collaborative experiences for your users.

Remember that collaborative editing is not just about technical implementationâ€”it's also about designing interactions that help users work together effectively. Consider user feedback, clear presence indicators, and thoughtful notifications to create a smooth collaborative experience.

For more information about specific components, check out the [Components documentation](/components).